// *************************************
//
// # jigsass-tools-bidi
// -> Painless bidirectional style authoring
//
// Author: TxHawks (tofu.hawks@gmail.com)
//
// *************************************

@charset 'UTF-8';

// -------------------------------------
// Dependencies
// -------------------------------------

@if (not mixin-exists(jigsass-rem)) {
  @error '`jigsass-tools-bidi` has a dependency on `jigsass-tools-typography`. Please import it.'
}

@if (not global-variable-exists(jigsass-default-unit)) {
  @error '`jigsass-tools-bidi` has a dependency on `jigsass-tools-typography`. Please import it.'
}





// -------------------------------------
// Variables
// -------------------------------------

/// The direction in which styles
/// should be outputted
/// ---
/// @type String
/// ---
$jigsass-direction: ltr !default;





// -------------------------------------
// Functions
// -------------------------------------

/// Translate `start` or `end` into either
/// `left` or `right`, depending on the current
/// value of `$jigsass-direction`;
/// ---
/// @param {String} $side
///   The side to translate into `left` or `right`. Can be `start` or `end`.
/// ---
/// @retrun {String} - The translated value of `$side`. `left` or `right`
/// ---
@function _jigsass-get-side($side) {
  @if (not index(start end, to-lower-case($side))) {
    @error '_jigsass-get-side: `$side` may only be `start` or `end`, but you passed `#{$side}`';
  }

  @if ($jigsass-direction == to-lower-case(ltr)) {
    @return if(to-lower-case($side) == start, left, right);
  }

  @return if(to-lower-case($side) == start, right, left);
}


/// Helper to convert a string representing a
/// untiless number into an actual unitless number
@function _jigsass-str2num($num-string) {
  $numbers: ('0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9);
  $is-neg: str-slice($num-string, 1, 1) == '-';
  $chars: if($is-neg, str-slice($num-string, 2), $num-string);
  $has-decimal: false;
  $decimal: 1;
  $num: 0;

  @for $i from 1 through str-length($chars) {
    $char: str-slice($chars, $i, $i);

    @if ($char == '.') {
      $has-decimal: true;
    }

    @else if (not $has-decimal) {
      $num: $num * 10 + map-get($numbers, $char);
    }

    @else {
      $decimal: $decimal * 10;
      $num: $num + map-get($numbers, $char) / $decimal;
    }
  }

  @return if($is-neg, -1 * $num, $num);
}


/// Trim whitespace from a string
/// ---
/// @param {String} $string
/// @param {Boolean} $leading [true]
/// @param {Boolean} $trailing [true]
///   Indicates if trailing whitespace will be removed
/// ---
/// @return {String} - The trimmed string
/// ---
/// @access private
/// ---
@function _jigsass-bidi-trim($string, $leading: true, $trailing: true) {
  @if ($leading and str-index($string, ' ') == 1) {
    $string: str-slice($string, 2);

    @if (str-index($string, ' ') == 1) {
      $string: _jigsass-bidi-trim($string, true, false);
    }
  }
  @if ($trailing and str-slice($string, -1) == ' ') {
    $string: str-slice($string, 1, -2);

    @if (str-slice($string, -1) == ' ') {
      $string: _jigsass-bidi-trim($string, false, true);
    }
  }

  @return $string;
}


/// Replace a substring inside a string
/// ---
/// @param {String} $string
///   The string to search in
/// @param {String} $substr
///   The substring to search for
/// @param {String} $new-substr
///   The substring to replace `$substr` with
/// @param {Boolean} $replace-all
///   Replace all instances of `$substr`, or just the first
/// @param {Boolean} $match-case
/// ---
/// @return {String} The replaced string
/// ---
@function jigsass-str-replace(
  $string,
  $substr,
  $new-substr: null,
  $replace-all: true,
  $match-case: true
) {
  // Coerce arguments into strings
  $string: inspect($string);
  $surstr: inspect($substr);
  $new-surstr: inspect($new-substr);

  @if ($string == $substr) { @return $new-substr; }

  $sub-index: if(
    $match-case,
    str-index($string, $substr),
    str-index(to-lower-case($string), $substr)
  );

  @if ($sub-index) {
    $sub-end-index: $sub-index + str-length($substr);

    $prefix: if($sub-index == 1, '', str-slice($string, 1, ($sub-index - 1)));
    $suffix: str-slice($string, $sub-end-index);

    // Recurse if replace all.
    @if ($replace-all and str-index($suffix, $substr)) {
      $suffix: jigsass-str-replace(
        $suffix,
        $substr,
        $new-substr,
        true,
        $match-case
      );
    }

    $_string: $prefix + ($new-substr or '') + $suffix;
    @return unquote(inspect($_string));
  }

  @return unquote(inspect($string));
}


/// Parse primary and secondary border radius values,
/// and return them as a map with the value of each
/// in its own key.
/// ---
/// @param {List} $values
///   primary and optionally secondary values for border-radius.
///
///   If secondary values are passed as well, one set of values
///   must be a `list` itself.
///   If that set is of a single value (i.e. as in CSS
///   `border-radius: 6px / 12px`), the value must be coerced
///   into a list (e.g `$values: 6px (12px,)`)
/// ---
/// @return {Map}
///   a map with `primary` and `secondary` keys holding lists of values.
/// ---
/// @access private
/// ---
@function _jigsass-parse-bdrs-values($values) {
  $primary: ();
  $secondary: ();

  $_first-found: false;
  $_first-is-list: false;

  @each $value in $values {
    @if (type-of($value) == list) {
      @if ($_first-found) {
        $secondary: $value;
      }

      @else if (not $_first-found) {
        $_first-found: true;
        $_first-is-list: true;

        $primary: $value;
      }
    }

    @else if (type-of($value) == number) {
      @if ($_first-is-list) {
        $secondary: append($secondary, $value)
      }
      @else if (not $_first-is-list) {
        $_first-found: true;

        $primary: append($primary, $value)
      }
    }
  }

  @if (length($primary) > 4) {
    @error '_jigsass-parse-bdrs-values: Border-radius can acceps a maximum' +
      'of four primary (horizontal) values, but your are trying to pass #{length($value)}';
  }

  @if (length($secondary) > 4) {
    @error '_jigsass-parse-bdrs-values: Border-radius can acceps a maximum' +
      'of four secondary (vertical) values, but your are trying to pass #{length($value)}';
  }

  @return (
    primary: $primary,
    secondary: if(length($secondary) > 0, $secondary, null)
  );
}





// -------------------------------------
// Mixins
// -------------------------------------






// -------------------------------------
// Helper Mixins
// -------------------------------------

/// Helper for simple text replacements
/// ---
@mixin _jigsass-bidi-simple($property, $values, $rem) {
  $_rtl: $jigsass-direction == rtl;

  $_prop: if(
    str-index($property, start),
    jigsass-str-replace($property, start, if($_rtl, right, left), $match-case: false),
    if(
      str-index($property, end),
      jigsass-str-replace($property, end, if($_rtl, left, right), $match-case: false),
      $property
    )
  );
  $_value: if(index(start end, $values), _jigsass-get-side($values), $values);

  @if ($rem) { @include jigsass-rem($_prop, $_value); }

  @else { #{$_prop}: $_value; }
}


/// Helper to interpret lists of four values as
/// `top-end-bottom-start` instead of 'top-right-bottom-left'.
@mixin _jigsass-bidi-sides($property, $values, $rem) {
  $_rtl: $jigsass-direction == rtl;

  @if ((length($values) == 4) and $_rtl) {
    $values: nth($values, 1) nth($values, 4) nth($values, 3) nth($values, 2);
  }

  @if ($rem) { @include jigsass-rem($property, $values); }

  @else { #{$property}: $values; }
}


/// Helper to transform linear gradients as if they were written
/// in a direction-agnostic manner (`start-to-end` and clockwise for ltr,
/// counter-clockwise for rtl).
/// ---
/// @param {String | List} $values
///   One or more strings to serve as background-image values.
/// ---
@mixin _jigsass-bidi-bgi($values) {
  $_rtl: $jigsass-direction == rtl;
  $_values-store: ();

  @each $value in $values {
    @if (str-index($value, 'linear-gradient(')) {
      @if (str-index($value, ' end') or str-index($value, ' start')) {
        @if (str-index($value, ' end')) {
          $value: jigsass-str-replace($value, ' end', if($_rtl, ' left', ' right'));
        }
        @if (str-index($value, ' start')) {
          $value: jigsass-str-replace($value, ' start', if($_rtl, ' right', ' left'));
        }
      }

      @else if ($_rtl) {
        $value: str-slice($value, str-index($value, 'linear-gradient(') + 16);
        $value: _jigsass-bidi-trim($value, true, false);

        $_angle: false;

        @if (str-index($value, deg)) {
          $_angle: map-merge((), (type: deg, index: str-index($value, deg)));
        }
        @else if (str-index($value, turn)) {
          $_angle: map-merge((), (type: turn, index: str-index($value, turn)));
        }
        @else if (str-index($value, grad)) {
          $_angle: map-merge((), (type: grad, index: str-index($value, grad)));
        }
        @else if (str-index($value, rad)) {
          $_angle: map-merge((), (type: rad, index: str-index($value, rad)));
        }


        @if ($_angle) {
          $_indx: map-get($_angle, index);
          $_type: map-get($_angle, type);
          $_end: $_indx - 1;

          $num-str: str-slice($value, 1, $_end);

          $num: _jigsass-str2num($num-str);

          @if ($_type == deg) { $num: abs($num - 360); }
          @else if ($_type == turn) {
            $num: abs($num - 1);
          }
          @else if ($_type == grad) { $num: abs($num - 400); }

          // When `rad`
          @else { $num: abs($num - 6.2831853072); }

          $value: unquote('linear-gradient(') + $num + str-slice($value, $_end + 1);
        }
      }
    }

    $_values-store: append($_values-store, $value, comma);
  }

  background-image: $_values-store;
}


/// Direction agnostic border radius
/// @param {List} $values
///   Instead of being processed left to right, values are
///   processed `top-start`, `top-end`, `bottom-end`, `bottom-start`.
///   with support for primary and optionally secondary border-radius
///   values for border-radius.
///
///   If secondary values are passed as well, one set of values
///   must be a `list` itself.
///   If that set is of a single value (i.e. as in CSS
///   `border-radius: 6px / 12px`), the value must be coerced
///   into a list (e.g `$values: 6px (12px,)`)
/// @param {Boolean} $rem
///   Determines if pixel values will be converted into rems.
/// ---
@mixin _jigsass-bidi-bdrs($values, $rem) {
  $_parssed-values: _jigsass-parse-bdrs-values($values);

  $_primary: map-get($_parssed-values, primary);
  $_secondary: map-get($_parssed-values, secondary);

  $_p-length: length($_primary);
  $_s-length: length($_secondary);

  $top-start: nth($_primary, 1);
  $top-end: if($_p-length > 1, nth($_primary, 2), false);
  $bottom-end: if($_p-length > 2, nth($_primary, 3), false);
  $bottom-start: if($_p-length > 3, nth($_primary, 4), false);

  $top-start-v: if($_secondary, nth($_secondary, 1), false);
  $top-end-v: if($_s-length > 1, nth($_secondary, 2), false);
  $bottom-end-v: if($_s-length > 2, nth($_secondary, 3), false);
  $bottom-start-v: if($_s-length > 3, nth($_secondary, 4), false);

  $_rtl: $jigsass-direction == rtl;

  // If no valid value is provided
  @if (index(null '' false, $values)) {
    border-radius: null;
  }

  @else {
    $ordered-values: if(
      $top-end,
      if($_rtl, $top-end $top-start, $top-start $top-end),
      $top-start
    );

    $bottom-values: ();

    @if ($bottom-end) {
      $bottom-values: if(
        $_rtl,
        ($bottom-start or $top-end) $bottom-end,
        $bottom-end ($bottom-start or null)
      );

      @each $radius in $bottom-values {
        $ordered-values: append($ordered-values, $radius, space);
      }
    }

    @if ($_secondary) {
      $top-values-v: if(
        $top-end-v,
        if($_rtl, $top-end-v $top-start-v, $top-start-v $top-end-v),
        $top-start-v
      );

      $bottom-values-v: ();
      @if ($bottom-end-v) {
        $bottom-values-v: if(
          $_rtl,
          ($bottom-start-v or $top-end-v) $bottom-end-v,
          $bottom-end-v ($bottom-start-v or null)
        );
      }

      $ordered-values: append($ordered-values, unquote(' / '));

      @each $radius in $top-values-v {
        $ordered-values: append($ordered-values, $radius, space);
      }

      @each $radius in $bottom-values-v {
        $ordered-values: append($ordered-values, $radius, space);
      }
    }

    @if ($rem) { @include jigsass-rem(border-radius, $ordered-values); }

    @else {  border-radius: $ordered-values; }
  }
}
