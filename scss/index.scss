// *************************************
//
// # jigsass-tools-bidi
// -> Painless bidirectional style authoring
//
// Author: TxHawks (tofu.hawks@gmail.com)
//
// *************************************

@charset 'UTF-8';

// -------------------------------------
// Dependencies
// -------------------------------------

@if (not mixin-exists(jigsass-rem)) {
  @error '`jigsass-tools-bidi` has a dependency on `jigsass-tools-typography`. Please import it.'
}

@if (not global-variable-exists(jigsass-default-unit)) {
  @error '`jigsass-tools-bidi` has a dependency on `jigsass-tools-typography`. Please import it.'
}





// -------------------------------------
// Variables
// -------------------------------------

/// The direction in which styles
/// should be outputted
/// ---
/// @type String
/// ---
$jigsass-direction: ltr !default;





// -------------------------------------
// Functions
// -------------------------------------

/// Translate `start` or `end` into either
/// `left` or `right`, depending on the current
/// value of `$jigsass-direction`;
/// ---
/// @param {String} $side
///   The side to translate into `left` or `right`. Can be `start` or `end`.
/// ---
/// @retrun {String} - The translated value of `$side`. `left` or `right`
/// ---
@function _jigsass-get-side($side) {
  @if (not index(start end, to-lower-case($side))) {
    @error '_jigsass-get-side: `$side` may only be `start` or `end`, but you passed `#{$side}`';
  }

  @if ($jigsass-direction == to-lower-case(ltr)) {
    @return if(to-lower-case($side) == start, left, right);
  }

  @return if(to-lower-case($side) == start, right, left);
}


/// Helper to convert a string representing a
/// untiless number into an actual unitless number
@function _jigsass-str2num($num-string) {
  $numbers: ('0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9);
  $is-neg: str-slice($num-string, 1, 1) == '-';
  $chars: if($is-neg, str-slice($num-string, 2), $num-string);
  $has-decimal: false;
  $decimal: 1;
  $num: 0;

  @for $i from 1 through str-length($chars) {
    $char: str-slice($chars, $i, $i);

    @if ($char == '.') {
      $has-decimal: true;
    }

    @else if (not $has-decimal) {
      $num: $num * 10 + map-get($numbers, $char);
    }

    @else {
      $decimal: $decimal * 10;
      $num: $num + map-get($numbers, $char) / $decimal;
    }
  }

  @return if($is-neg, -1 * $num, $num);
}


/// Trim whitespace from a string
/// ---
/// @param {String} $string
/// @param {Boolean} $leading [true]
/// @param {Boolean} $trailing [true]
///   Indicates if trailing whitespace will be removed
/// ---
/// @return {String} - The trimmed string
/// ---
/// @access private
/// ---
@function _jigsass-bidi-trim($string, $leading: true, $trailing: true) {
  @if ($leading and str-index($string, ' ') == 1) {
    $string: str-slice($string, 2);

    @if (str-index($string, ' ') == 1) {
      $string: _jigsass-bidi-trim($string, true, false);
    }
  }
  @if ($trailing and str-slice($string, -1) == ' ') {
    $string: str-slice($string, 1, -2);

    @if (str-slice($string, -1) == ' ') {
      $string: _jigsass-bidi-trim($string, false, true);
    }
  }

  @return $string;
}


/// Replace a substring inside a string
/// ---
/// @param {String} $string
///   The string to search in
/// @param {String} $substr
///   The substring to search for
/// @param {String} $new-substr
///   The substring to replace `$substr` with
/// @param {Boolean} $replace-all
///   Replace all instances of `$substr`, or just the first
/// @param {Boolean} $match-case
/// ---
/// @return {String} The replaced string
/// ---
@function jigsass-str-replace(
  $string,
  $substr,
  $new-substr: null,
  $replace-all: true,
  $match-case: true
) {
  // Coerce arguments into strings
  $string: inspect($string);
  $surstr: inspect($substr);
  $new-surstr: inspect($new-substr);

  @if ($string == $substr) { @return $new-substr; }

  $sub-index: if(
    $match-case,
    str-index($string, $substr),
    str-index(to-lower-case($string), $substr)
  );

  @if ($sub-index) {
    $sub-end-index: $sub-index + str-length($substr);

    $prefix: if($sub-index == 1, '', str-slice($string, 1, ($sub-index - 1)));
    $suffix: str-slice($string, $sub-end-index);

    // Recurse if replace all.
    @if ($replace-all and str-index($suffix, $substr)) {
      $suffix: jigsass-str-replace(
        $suffix,
        $substr,
        $new-substr,
        true,
        $match-case
      );
    }

    $_string: $prefix + ($new-substr or '') + $suffix;
    @return unquote(inspect($_string));
  }

  @return unquote(inspect($string));
}


/// Utility function to transform background-position
/// values in a `start-to-end`, direction-agnostic manner
@function _jigsass-bidi-bgp($position) {
  $_rtl: $jigsass-direction == rtl;
  $_value-store: ();

  @for $i from 1 through length($position) {
    $_value: nth($position, $i);
    $_type: type-of($_value);

    @if (index(start end, $_value)) {
      @if ($i != 1) {
        @error 'jigsass-bidi: horizontal position must be passed before vertical ' +
          '(When trying to set #{$position}).'
      }
      $_sides: (start: if($_rtl, right, left), end: if($_rtl, left, right));

      $_value: map-get($_sides, $_value);
    }

    @else if ($_type == number and $_rtl) {
      @if ($i == 1 and unit($_value) == '%') {
        $_value: if(
          length($position) == 1,
          abs($_value - 100%) $_value,
          abs($_value - 100%)
        );
      }
    }

    $_value-store: append($_value-store, $_value);
  }

  @return $_value-store;
}





// -------------------------------------
// Mixins
// -------------------------------------






// -------------------------------------
// Helper Mixins
// -------------------------------------



/// Direction agnostic `direction`
/// ---
/// @param {String} $direction
///   `ste` = start-to-end, `ets` = end-to-start.
///   `rtl` and `ltr` will be printed as is, without
///   trasformation, regardless of the JigSass direction context
/// ---
@mixin _jigsass-bidi-direction($direction) {
  @if (not index(ltr rtl ste ets, $direction)) {
    @error 'jigsass-bidi: #{$direction} is not a valid direction value. ' +
      'Try `ste` (contextual - start-to-end), `ets` (contextual - end-to-start)' +
      '`ltr` (absolute, will not be converted) or `rtl` (absolute, will not be converted).';
  }

  $_rtl: $jigsass-direction == rtl;

  @if ($direction == ste) { $direction: if($_rtl, rtl, ltr); }
  @if ($direction == ets) { $direction: if($_rtl, ltr, rtl); }

  direction: $direction;
}


/// Helper for simple text replacements
/// ---
@mixin _jigsass-bidi-simple($property, $values, $rem) {
  $_rtl: $jigsass-direction == rtl;

  $_prop: if(
    str-index($property, start),
    jigsass-str-replace($property, start, if($_rtl, right, left), $match-case: false),
    if(
      str-index($property, end),
      jigsass-str-replace($property, end, if($_rtl, left, right), $match-case: false),
      $property
    )
  );
  $_value: if(index(start end, $values), _jigsass-get-side($values), $values);

  @if ($rem) { @include jigsass-rem($_prop, $_value); }

  @else { #{$_prop}: $_value; }
}


/// Helper to interpret lists of four values as
/// `top-end-bottom-start` instead of 'top-right-bottom-left'.
@mixin _jigsass-bidi-sides($property, $values, $rem) {
  $_rtl: $jigsass-direction == rtl;

  @if ((length($values) == 4) and $_rtl) {
    $values: nth($values, 1) nth($values, 4) nth($values, 3) nth($values, 2);
  }

  @if ($rem) { @include jigsass-rem($property, $values); }

  @else { #{$property}: $values; }
}


/// Helper to transform linear gradients as if they were written
/// in a direction-agnostic manner (`start-to-end` and clockwise for ltr,
/// counter-clockwise for rtl).
/// ---
/// @param {String | List} $values
///   One or more strings to serve as background-image values.
/// ---
@mixin _jigsass-bidi-bgi($values) {
  $_rtl: $jigsass-direction == rtl;
  $_values-store: ();

  @each $value in $values {
    @if (str-index($value, 'linear-gradient(')) {
      @if (str-index($value, ' end') or str-index($value, ' start')) {
        @if (str-index($value, ' end')) {
          $value: jigsass-str-replace($value, ' end', if($_rtl, ' left', ' right'));
        }
        @if (str-index($value, ' start')) {
          $value: jigsass-str-replace($value, ' start', if($_rtl, ' right', ' left'));
        }
      }

      @else if ($_rtl) {
        $value: str-slice($value, str-index($value, 'linear-gradient(') + 16);
        $value: _jigsass-bidi-trim($value, true, false);

        $_angle: false;

        @if (str-index($value, deg)) {
          $_angle: map-merge((), (type: deg, index: str-index($value, deg)));
        }
        @else if (str-index($value, turn)) {
          $_angle: map-merge((), (type: turn, index: str-index($value, turn)));
        }
        @else if (str-index($value, grad)) {
          $_angle: map-merge((), (type: grad, index: str-index($value, grad)));
        }
        @else if (str-index($value, rad)) {
          $_angle: map-merge((), (type: rad, index: str-index($value, rad)));
        }


        @if ($_angle) {
          $_indx: map-get($_angle, index);
          $_type: map-get($_angle, type);
          $_end: $_indx - 1;

          $num-str: str-slice($value, 1, $_end);

          $num: _jigsass-str2num($num-str);

          @if ($_type == deg) { $num: abs($num - 360); }
          @else if ($_type == turn) {
            $num: abs($num - 1);
          }
          @else if ($_type == grad) { $num: abs($num - 400); }

          // When `rad`
          @else { $num: abs($num - 6.2831853072); }

          $value: unquote('linear-gradient(') + $num + str-slice($value, $_end + 1);
        }
      }
    }

    $_values-store: append($_values-store, $value, comma);
  }

  background-image: $_values-store or $values;
}


/// Direction agnostic background-position
///
/// transforms background-position values in a
/// `start-to-end`, direction-agnostic manner
/// ---
/// @param {String | Number | List} $values
///   Only numbers specified in percentage units can be
///   transformed, as other units require knowledge of the
///   container's width.
///
///   For multiple positions (in cases of multiple background images),
///   each _set_ of position values must be a space-separated list
///   inside a comma-separated list.
///
///   For example, to get:
///   '''css
///     background-position: 25% 50%, left
///   '''
///
///   The `$values` argument should be passed as:
///   '''scss
///     $values: (25% 50%, left)
///   '''
/// @param {Boolean} $rem
///   Determines if pixel values will be converted into rems.
/// ---
@mixin _jigsass-bidi-bgp($values, $rem) {
  $_positions: ();

  $_multi-bgs: list-separator($values) == comma;

  @each $value in $values {
    @if (length($value) > 2) {
      @error 'jigsass-bidi: `background-position` only takes two arguments per' +
        'position, but you are trying to pass #{length($value)}. Did you mean ' +
        'to specify multiple positions?';
    }
  }

  @if ($_multi-bgs) {
    @each $position in $values {
      $_positions: append($_positions, _jigsass-bidi-bgp($position), comma);
    }
  }
  @else { $_positions: append($_positions, _jigsass-bidi-bgp($values), comma); }

  @if ($rem) { @include jigsass-rem(background-position, $_positions); }
  @else { background-position: $_positions; }
}


/// Direction agnostic border radius
/// @param {List} $values
///   Instead of being processed left to right, values are
///   processed `top-start`, `top-end`, `bottom-end`, `bottom-start`.
///   with support for primary and optionally secondary border-radius
///   values for border-radius.
///
///   When secondary values are set, each _set_ of radii must be a
///   space-separated list inside a comma-separated list.
///
///   For example, to get:
///   '''css
///     border-radius: 12px 6px / 18px;
///   '''
///
///   The `$values` argument should be passed as:
///   '''scss
///     $values: (12px 6px, 18px)
///   '''
/// @param {Boolean} $rem
///   Determines if pixel values will be converted into rems.
/// ---
@mixin _jigsass-bidi-bdrs($values, $rem) {
  $_has-secondary: if(list-separator($values) == comma, (), null);
  $_rtl: $jigsass-direction == rtl;

  @if (length($values) > 4) {
    @error 'jigsass-bidi: `border-radius` can have a maximum of 4 primary or ' +
      'secondary values, you are trying to pass #{length($values)}. Are you ' +
      'trying to set secondary (vertical) radii?';
  }
  @if ($_has-secondary and length($values) > 2) {
    @error 'jigsass-bidi: `border-radius` can have a maximum of 2 **sets** of ' +
      'of 4 values, but you are trying to set #{length($values)}.';
  }
  @if ($_has-secondary) {
    @each $set in $values {
      @if (length($set) > 4) {
        @error 'jigsass-bidi: `border-radius` accepts a maximum of 4 primary or ' +
          'secondary values, you are trying to pass #{length($set)}.';
      }
    }
  }

  $_primary: if($_has-secondary, nth($values, 1), $values);
  $_secondary: if($_has-secondary, nth($values, 2), null);

  $_p-length: length($_primary);
  $_s-length: length($_secondary);

  $top-start: nth($_primary, 1);
  $top-end: if($_p-length > 1, nth($_primary, 2), false);
  $bottom-end: if($_p-length > 2, nth($_primary, 3), false);
  $bottom-start: if($_p-length > 3, nth($_primary, 4), false);

  $top-start-v: if($_secondary, nth($_secondary, 1), false);
  $top-end-v: if($_s-length > 1, nth($_secondary, 2), false);
  $bottom-end-v: if($_s-length > 2, nth($_secondary, 3), false);
  $bottom-start-v: if($_s-length > 3, nth($_secondary, 4), false);

  // If no valid value is provided
  @if (index(null '' false, $values)) {
    border-radius: null;
  }

  @else {
    $ordered-values: if(
      $top-end,
      if($_rtl, $top-end $top-start, $top-start $top-end),
      $top-start
    );

    $bottom-values: ();

    @if ($bottom-end) {
      $bottom-values: if(
        $_rtl,
        ($bottom-start or $top-end) $bottom-end,
        $bottom-end ($bottom-start or null)
      );

      @each $radius in $bottom-values {
        $ordered-values: append($ordered-values, $radius, space);
      }
    }

    @if ($_secondary) {
      $top-values-v: if(
        $top-end-v,
        if($_rtl, $top-end-v $top-start-v, $top-start-v $top-end-v),
        $top-start-v
      );

      $bottom-values-v: ();
      @if ($bottom-end-v) {
        $bottom-values-v: if(
          $_rtl,
          ($bottom-start-v or $top-end-v) $bottom-end-v,
          $bottom-end-v ($bottom-start-v or null)
        );
      }

      $ordered-values: append($ordered-values, unquote(' / '));

      @each $radius in $top-values-v {
        $ordered-values: append($ordered-values, $radius, space);
      }

      @each $radius in $bottom-values-v {
        $ordered-values: append($ordered-values, $radius, space);
      }
    }

    @if ($rem) { @include jigsass-rem(border-radius, $ordered-values); }

    @else {  border-radius: $ordered-values; }
  }
}
